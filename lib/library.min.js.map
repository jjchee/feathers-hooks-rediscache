{"version":3,"sources":["webpack://library/webpack/universalModuleDefinition","webpack://library/webpack/bootstrap","webpack://library/external \"chalk\"","webpack://library/./src/index.js","webpack://library/./src/routes/cache.js","webpack://library/external \"express\"","webpack://library/./src/routes/helpers/redis.js","webpack://library/./src/redisClient.js","webpack://library/external \"redis\"","webpack://library/./src/hooks/cache.js","webpack://library/./src/hooks/redis.js","webpack://library/external \"moment\"","webpack://library/./src/hooks/helpers/path.js","webpack://library/external \"qs\""],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","_cache","_interopRequireDefault","_redisClient","_cache2","_redis","obj","default","redisClient","cacheRoutes","hookCache","hookRemoveCacheInformation","redisBeforeHook","redisAfterHook","_express","app","router","express","Router","client","h","RedisCache","req","res","flushall","status","json","message","target","decodeURIComponent","params","query","hasQueryString","keys","length","url","split","slice","join","err","reply","clearSingle","then","end","lrange","Array","isArray","clearGroup","constructor","this","Promise","resolve","reject","del","clearAll","e","array","cacheOptions","retryInterval","redisOptions","assign","retry_strategy","options","set","undefined","env","console","log","chalk","yellow","redis","createClient","on","green","_chalk","hook","defaults","result","cache","wrapped","cached","duration","defaultDuration","path","cacheKey","parsePath","expiresOn","moment","add","parent","group","JSON","stringify","expire","cyan","humanize","data","parse","format","immediateCacheKey","_moment","_path","config","removePathFromCacheKey","parseNestedRoutes","q","remove","id","re","RegExp","match","exec","route","includes","replace","parseNestedPath","qs","encode","_qs"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,UAAW,GAAIH,GACI,iBAAZC,QACdA,QAAiB,QAAID,IAErBD,EAAc,QAAIC,IARpB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gBClFrDtC,EAAOD,QAAUwC,QAAQ,U,+FCAzB,IAAAC,EAAAC,EAAAF,EAAA,IACAG,EAAAD,EAAAF,EAAA,IACAI,EAAAJ,EAAA,GAEAK,EAAAL,EAAA,GAAyD,SAAAE,EAAAI,GAAA,OAAAA,KAAAlB,WAAAkB,EAAA,CAAAC,QAAAD,GAAA9C,EAAA+C,QAG1C,CACbC,sBACAC,sBACAC,kBACAC,oDACAC,yBACAC,wBACDpD,EAAAD,UAAA+C,S,+FCdD,IAAAO,EAAAZ,EAAAF,EAAA,IAEAK,EAAAH,EAAAF,EAAA,IAAyC,SAAAE,EAAAI,GAAA,OAAAA,KAAAlB,WAAAkB,EAAA,CAAAC,QAAAD,GAsIxC9C,EAAA+C,QA/HD,SAAgBQ,GACd,MAAMC,EAASC,UAAQC,SACjBC,EAASJ,EAAIlC,IAAI,eACjBuC,EAAI,IAAIC,UAAWF,GA2HzB,OAzHAH,EAAOnC,IAAI,SAAU,CAACyC,EAAKC,KACzBJ,EAAOK,SAAS,QAAS,KACvBD,EAAIE,OAZM,KAYUC,KAAK,CACvBC,QAAS,gBACTF,OAdQ,UAoBdT,EAAOnC,IAAI,kBAAmB,CAACyC,EAAKC,KAClC,IAAIK,EAASC,mBAAmBP,EAAIQ,OAAO,IAE3C,MAAMC,EAAQT,EAAIS,MACZC,EAAkBD,GAAwC,IAA9BrD,OAAOuD,KAAKF,GAAOG,OAIjDN,EAAOM,QACLF,IAEFJ,EAASC,mBAAmBP,EAAIa,IAAIC,MAAM,KAAKC,MAAM,GAAGC,KAAK,OAI/DnB,EAAOtC,IAAK,GAAE+C,EAAU,CAACW,EAAKC,KACxBD,EACFhB,EAAIE,OAnCY,KAmCcC,KAAK,CACjCC,QAAS,uBAAyBY,EAAIZ,UAIpCa,EAEFpB,EAAEqB,YAAYb,GAAQc,KAAK5D,IACzByC,EAAIE,OA7CF,KA6CkBC,KAAK,CACvBC,QAAU,0BAAyBK,EACjC,OAAS,sBAAsBJ,IACjCH,OAhDA,QAyDJF,EAAIE,OAzDA,KAyDgBC,KAAK,CACvBC,QAAU,kCAAiCK,EACzC,OAAS,sBAAsBJ,IACjCH,OA3DU,SAkElBF,EAAIE,OAhEa,KAgEUkB,QAK/B3B,EAAOnC,IAAI,iBAAkB,CAACyC,EAAKC,KACjC,IAAIK,EAASC,mBAAmBP,EAAIQ,OAAO,IAIvCF,EAAOM,QACTN,EAAS,SAAWA,EAGpBT,EAAOyB,OAAOhB,EAAQ,GAAI,EAAG,CAACW,EAAKC,KAC7BD,EACFhB,EAAIE,OAjFY,KAiFcC,KAAK,CACjCC,QAAS,uBAAyBY,EAAIZ,UAIpCa,GAASK,MAAMC,QAAQN,IAAWA,EAAMN,OAAS,EAEnDd,EAAE2B,WAAWnB,GAAQc,KAAK5D,IACxByC,EAAIE,OA3FF,KA2FkBC,KAAK,CACvBC,QACG,oCAAmCE,mBAAmBP,EAAIQ,OAAO,IACpEL,OA9FA,QAuGJF,EAAIE,OAvGA,KAuGgBC,KAAK,CACvBC,QACG,4CAA2CE,mBAAmBP,EAAIQ,OAAO,IAC5EL,OAzGU,SA+GlBF,EAAIE,OA7Ga,KA6GUkB,QAmBxB3B,GAGYvD,EAAAD,UAAA+C,S,cC1IrB9C,EAAOD,QAAUwC,QAAQ,Y,+FC6HxBxC,EAAA+C,QA7Hc,MACbyC,YAAY7B,GACV8B,KAAK9B,OAASA,EA0EhBsB,YAAYlD,GACV,OAAO,IAAI2D,QAAQ,CAACC,EAASC,KAC3BH,KAAK9B,OAAOkC,IAAK,GAAE9D,EAAO,CAACgD,EAAKC,KAC1BD,GAAKa,GAAO,GACF,IAAVZ,GACFW,GAAQ,GAEVA,GAAQ,OASdJ,WAAWxD,GACT,OAAO,IAAI2D,QAAQ,CAACC,EAASC,KAC3BH,KAAK9B,OAAOyB,OAAOrD,EAAK,GAAI,EAAG,CAACgD,EAAKC,KAC/BD,GACFa,EAAOb,GAETU,KAAKK,SAASd,GAAOE,KACnBO,KAAK9B,OAAOkC,IAAI9D,EAAK,CAACgE,EAAGzE,KACvBqE,EAAc,IAANrE,UAWlBwE,SAASE,GACP,OAAO,IAAIN,QAAQC,IACZK,EAAMtB,QAAQiB,GAAQ,GAC3B,IAAInF,EAAI,EAER,KAAQA,EAAIwF,EAAMtB,OAAQlE,IACxBiF,KAAKR,YAAYe,EAAMxF,IAAI0E,KAAK5D,IAC1Bd,IAAMwF,EAAMtB,OAAS,GACvBiB,EAAQrE,SAMlBrB,EAAAD,UAAA+C,S,wFC1Ha,WACb,MAAMQ,EAAMkC,KACNQ,EAAe1C,EAAIlC,IAAI,eAAiB,GACxC6E,EAAgBD,EAAaC,eAAiB,IAC9CC,EAAejF,OAAOkF,OAAO,GAAIX,KAAKpE,IAAI,SAAU,CACxDgF,eAAgB,SAAUC,GAMxB,OALA/C,EAAIgD,IAAI,mBAAeC,GAEE,SAArBP,EAAaQ,KACfC,QAAQC,IAAOC,UAAMC,OAAO,WAAf,kBAERX,KAGLvC,EAASmD,UAAMC,aAAaZ,GAWlC,OATA5C,EAAIgD,IAAI,cAAe5C,GAEvBA,EAAOqD,GAAG,QAAS,KACjBzD,EAAIgD,IAAI,cAAe5C,GAEE,SAArBsC,EAAaQ,KACfC,QAAQC,IAAOC,UAAMK,MAAM,WAAd,gBAGVxB,MA5BT,IAAA5C,EAAAH,EAAAF,EAAA,IACA0E,EAAAxE,EAAAF,EAAA,IAA0B,SAAAE,EAAAI,GAAA,OAAAA,KAAAlB,WAAAkB,EAAA,CAAAC,QAAAD,GA4BzB7C,EAAAD,UAAA+C,S,cC7BD9C,EAAOD,QAAUwC,QAAQ,U,sFCQlB,SAAe8D,GACpB,OAAO,SAAUa,GACf,MAAMlB,EAAekB,EAAK5D,IAAIlC,IAAI,cAIlC,GAFAiF,EAAUpF,OAAOkF,OAAO,GAAIgB,EAAUnB,EAAcK,IAE/Ca,EAAKE,OAAOhF,eAAe,SAAU,CACxC,IAAIiF,EAAQ,GAEZ,GAAIjC,MAAMC,QAAQ6B,EAAKE,QAAS,CAC9B,MAAMrB,EAAQmB,EAAKE,OAEnBC,EAAMC,QAAUvB,EAChBmB,EAAKE,OAAS,GAGhBC,EAAQpG,OAAOkF,OAAO,GAAIkB,EAAO,CAC/BE,QAAQ,EACRC,SAAUnB,EAAQmB,UAAYnB,EAAQoB,kBAGxCP,EAAKE,OAAOC,MAAQA,EAEtB,OAAO5B,QAAQC,QAAQwB,K,yBAIpB,SAAgCb,GACrC,OAAO,SAAUa,GAIf,OAHIA,EAAKE,OAAOhF,eAAe,iBACtB8E,EAAKE,OAAOC,MAEd5B,QAAQC,QAAQwB,KApC3B,MAAMC,EAAW,CACfM,gBAAiB,Q,sFC6CZ,SAAepB,GACpB,OAAO,SAAUa,GACf,MAAMlB,EAAekB,EAAK5D,IAAIlC,IAAI,cAIlC,OAFAiF,EAAUpF,OAAOkF,OAAO,GAAIgB,EAAUnB,EAAcK,GAE7C,IAAIZ,QAAQC,IACjB,IAAKwB,EAAKE,OAAOC,MAAME,OAAQ,CAC7B,MAAMC,EAAWN,EAAKE,OAAOC,MAAMG,UAAYnB,EAAQoB,gBACjD/D,EAASwD,EAAK5D,IAAIlC,IAAI,eAEvBsC,GACHgC,EAAQwB,GAGV,MAAMQ,EAAOR,EAAK7C,OAAOsD,WAAY,EAAAC,aAAUV,EAAMb,GAGrDpF,OAAOkF,OAAOe,EAAKE,OAAOC,MAAO,CAC/BE,QAAQ,EACRC,SAAUA,EACVK,WAAW,EAAAC,aAASC,IAAID,UAAON,SAASA,EAAU,YAClDQ,OAAQd,EAAKQ,KACbO,MAAOf,EAAKQ,KAAQ,SAAQR,EAAKQ,KAAS,GAC1C5F,IAAK4F,IAGPhE,EAAO4C,IAAIoB,EAAMQ,KAAKC,UAAUjB,EAAKE,SACrC1D,EAAO0E,OAAOV,EAAMR,EAAKE,OAAOC,MAAMG,UAGlB,SAAhBnB,EAAQG,MACVC,QAAQC,IAAK,GAAEC,UAAM0B,KAAK,oBAAoB1B,UAAMK,MAAMU,oBAC1DjB,QAAQC,IAAK,gBAAeoB,UAAON,SAASA,EAAU,WAAWc,gBAIrE,GAAIpB,EAAKE,OAAOC,MAAMjF,eAAe,WAAY,CAC/C,MAAM,QAAEkF,GAAYJ,EAAKE,OAAOC,MAEhCH,EAAKE,OAASE,EAGhB5B,EAAQwB,O,SAnFP,SAAgBb,GACrB,OAAO,SAAUa,GACf,MAAMlB,EAAekB,EAAK5D,IAAIlC,IAAI,cAIlC,OAFAiF,EAAUpF,OAAOkF,OAAO,GAAIgB,EAAUnB,EAAcK,GAE7C,IAAIZ,QAAQC,IACjB,MAAMhC,EAASwD,EAAK5D,IAAIlC,IAAI,eAEvBsC,GACHgC,EAAQwB,GAGV,MAAMQ,GAAO,EAAAE,aAAUV,EAAMb,GAE7B3C,EAAOtC,IAAIsG,EAAM,CAAC5C,EAAKC,KAErB,GADY,OAARD,GAAcY,EAAQwB,GACtBnC,EAAO,CACT,IAAIwD,EAAOL,KAAKM,MAAMzD,GACtB,MAAMyC,GAAW,EAAAM,WAAOS,EAAKlB,MAAMQ,WAAWY,OAAO,2BAErDvB,EAAKE,OAASmB,EACd7C,EAAQwB,GAGY,SAAhBb,EAAQG,MACVC,QAAQC,IAAK,GAAEC,UAAM0B,KAAK,yCAAyC1B,UAAMK,MAAMU,OAC/EjB,QAAQC,IAAK,gBAAec,YAGI,IAA9BnB,EAAQqC,oBACVxB,EAAK7C,OAAOsD,SAAWD,GAEzBhC,EAAQwB,SA3ClB,IAAAyB,EAAAlG,EAAAF,EAAA,IACA0E,EAAAxE,EAAAF,EAAA,IACAqG,EAAArG,EAAA,IAA2C,SAAAE,EAAAI,GAAA,OAAAA,KAAAlB,WAAAkB,EAAA,CAAAC,QAAAD,GAE3C,MAAMsE,EAAW,CACfX,IAAK,aACLiB,gBAAiB,MACjBiB,mBAAmB,I,cCPrB1I,EAAOD,QAAUwC,QAAQ,W,0FCezB,SAAmB2E,EAAM2B,EAAS,CAACC,wBAAwB,EAAOC,mBAAmB,IACnF,MAAMC,EAAI9B,EAAK7C,OAAOC,OAAS,GACzB2E,EAASJ,EAAOC,uBAChBC,EAAoBF,EAAOE,kBACjC,IAAIrB,EAAOuB,GAAU/B,EAAKgC,GAAK,GAAM,GAAEhC,EAAKQ,MAEvCuB,GAAUF,IACbrB,EApBJ,SAAyBA,EAAMrD,GAC7B,MAAM8E,EAAK,IAAIC,OAAO,oBAAqB,KAC3C,IAAIC,EAAQ,KAEZ,KAAmC,QAA3BA,EAAQF,EAAGG,KAAK5B,KAClBzG,OAAOuD,KAAKH,EAAOkF,OAAOC,SAASH,EAAM,MAC3C3B,EAAOA,EAAK+B,QAAQJ,EAAM,GAAIhF,EAAOkF,MAAMF,EAAM,MAIrD,OAAO3B,EAUEgC,CAAgBhC,EAAMR,EAAK7C,SAGhC6C,EAAKgC,IACa,IAAhBxB,EAAKjD,QAAiBwE,IACxBvB,GAAQ,KAENzG,OAAOuD,KAAKwE,GAAGvE,OAAS,EAC1BiD,GAAS,GAAER,EAAKgC,MAAMS,UAAGxB,UAAUa,EAAG,CAAEY,QAAQ,MAEhDlC,GAAS,GAAER,EAAKgC,IAGdjI,OAAOuD,KAAKwE,GAAGvE,OAAS,IAC1BiD,GAAS,IAAGiC,UAAGxB,UAAUa,EAAG,CAAEY,QAAQ,KAI1C,OAAOlC,GAxCT,IAAoB7E,EAApBgH,GAAoBhH,EAApBN,EAAA,MAAoBM,EAAAlB,WAAAkB,EAAA,CAAAC,QAAAD,I,cCApB7C,EAAOD,QAAUwC,QAAQ","file":"library.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"library\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"library\"] = factory();\n\telse\n\t\troot[\"library\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = require(\"chalk\");","import cacheRoutes from './routes/cache';\nimport redisClient from './redisClient';\nimport { cache as hookCache } from './hooks/cache';\nimport { removeCacheInformation as hookRemoveCacheInformation } from './hooks/cache';\nimport { before as redisBeforeHook} from './hooks/redis';\nimport { after as redisAfterHook} from './hooks/redis';\n\nexport default {\n  redisClient,\n  cacheRoutes,\n  hookCache,\n  hookRemoveCacheInformation,\n  redisBeforeHook,\n  redisAfterHook\n};\n","import express from 'express';\n\nimport RedisCache from './helpers/redis';\n\nconst HTTP_OK = 200;\nconst HTTP_NO_CONTENT = 204;\nconst HTTP_SERVER_ERROR = 500;\nconst HTTP_NOT_FOUND = 404;\n\nfunction routes(app) {\n  const router = express.Router();\n  const client = app.get('redisClient');\n  const h = new RedisCache(client);\n\n  router.get('/clear', (req, res) => {\n    client.flushall('ASYNC', () => {\n      res.status(HTTP_OK).json({\n        message: 'Cache cleared',\n        status: HTTP_OK\n      });\n    });\n  }); // clear a unique route\n\n  // clear a unique route\n  router.get('/clear/single/*', (req, res) => {\n    let target = decodeURIComponent(req.params[0]);\n    // Formated options following ?\n    const query = req.query;\n    const hasQueryString = (query && (Object.keys(query).length !== 0));\n\n    // Target should always be defined as Express router raises 404\n    // as route is not handled\n    if (target.length) {\n      if (hasQueryString) {\n      // Keep queries in a single string with the taget\n        target = decodeURIComponent(req.url.split('/').slice(3).join('/'));\n      }\n\n      // Gets the value of a key in the redis client\n      client.get(`${target}`, (err, reply) => {\n        if (err) {\n          res.status(HTTP_SERVER_ERROR).json({\n            message: 'something went wrong' + err.message\n          });\n        } else {\n          // If the key existed\n          if (reply) {\n            // Clear existing cached key\n            h.clearSingle(target).then(r => {\n              res.status(HTTP_OK).json({\n                message: `cache cleared for key (${hasQueryString ?\n                  'with' : 'without'} params): ${target}`,\n                status: HTTP_OK\n              });\n            });\n          } else {\n            /**\n             * Empty reply means the key does not exist.\n             * Must use HTTP_OK with express as HTTP's RFC stats 204 should not\n             * provide a body, message would then be lost.\n             */\n            res.status(HTTP_OK).json({\n              message: `cache already cleared for key (${hasQueryString ?\n                'with' : 'without'} params): ${target}`,\n              status: HTTP_NO_CONTENT\n            });\n          }\n\n        }\n      });\n    } else {\n      res.status(HTTP_NOT_FOUND).end();\n    }\n  });\n\n  // clear a group\n  router.get('/clear/group/*', (req, res) => {\n    let target = decodeURIComponent(req.params[0]);\n\n    // Target should always be defined as Express router raises 404\n    // as route is not handled\n    if (target.length) {\n      target = 'group-' + target;\n      // Returns elements of the list associated to the target/key 0 being the\n      // first and -1 specifying get all till the latest\n      client.lrange(target, 0, -1, (err, reply) => {\n        if (err) {\n          res.status(HTTP_SERVER_ERROR).json({\n            message: 'something went wrong' + err.message\n          });\n        } else {\n          // If the list/group existed and contains something\n          if (reply && Array.isArray(reply) && (reply.length > 0)) {\n            // Clear existing cached group key\n            h.clearGroup(target).then(r => {\n              res.status(HTTP_OK).json({\n                message:\n                  `cache cleared for the group key: ${decodeURIComponent(req.params[0])}`,\n                status: HTTP_OK\n              });\n            });\n          } else {\n            /**\n             * Empty reply means the key does not exist.\n             * Must use HTTP_OK with express as HTTP's RFC stats 204 should not\n             * provide a body, message would then be lost.\n             */\n            res.status(HTTP_OK).json({\n              message:\n                `cache already cleared for the group key: ${decodeURIComponent(req.params[0])}`,\n              status: HTTP_NO_CONTENT\n            });\n          }\n        }\n      });\n    } else {\n      res.status(HTTP_NOT_FOUND).end();\n    }\n  });\n\n  // add route to display cache index\n  // this has been removed for performance issues\n  // router.get('/index', (req, res) => {\n  //   let results = new Set();\n\n  //   h.scanAsync('0', '*', results)\n  //     .then(data => {\n  //       res.status(200).json(data);\n  //     })\n  //     .catch(err => {\n  //       res.status(404).json(err);\n  //     });\n\n  // });\n\n  return router;\n}\n\nexport default routes;\n","module.exports = require(\"express\");","export default class RedisCache {\n  constructor(client) {\n    this.client = client;\n  }\n\n  /**\n   * scan the redis index\n   */\n  // scan() {\n  //   // starts at 0 if cursor is again 0 it means the iteration is finished\n  //   let cursor = '0';\n\n  //   return new Promise((resolve, reject) => {\n  //     this.client.scan(cursor, 'MATCH', '*', 'COUNT', '100', (err, reply) => {\n  //       if (err) {\n  //         reject(err);\n  //       }\n\n  //       cursor = reply[0];\n  //       if (cursor === '0') {\n  //         resolve(reply[1]);\n  //       } else {\n  //         // do your processing\n  //         // reply[1] is an array of matched keys.\n  //         // console.log(reply[1]);\n  //         return this.scan();\n  //       }\n  //       return false;\n  //     });\n\n  //   });\n  // }\n\n  /**\n   * Async scan of the redis index\n   * Do not for get to passin a Set\n   * myResults = new Set();\n   *\n   * scanAsync('0', \"NOC-*[^listen]*\", myResults).map(\n   *   myResults => { console.log( myResults); }\n   * );\n   *\n   * @param {String} cursor - string '0'\n   * @param {String} patern - string '0'\n   * @param {Set} returnSet - pass a set to have unique keys\n   */\n  // scanAsync(cursor, pattern, returnSet) {\n  //   // starts at 0 if cursor is again 0 it means the iteration is finished\n\n  //   return new Promise((resolve, reject) => {\n  //     this.client.scan(cursor, 'MATCH', pattern, 'COUNT', '100', (err, reply) => {\n\n  //       if (err) {\n  //         reject(err);\n  //       }\n\n  //       cursor = reply[0];\n  //       const keys = reply[1];\n\n  //       keys.forEach((key, i) => {\n  //         returnSet.add(key);\n  //       });\n\n  //       if (cursor === '0') {\n  //         resolve(Array.from(returnSet));\n  //       }\n\n  //       return this.scanAsync(cursor, pattern, returnSet);\n  //     });\n  //   });\n  // }\n\n  /**\n   * Clean single item from the cache\n   * @param {string} key - the key to find in redis\n   */\n  clearSingle(key) {\n    return new Promise((resolve, reject) => {\n      this.client.del(`${key}`, (err, reply) => {\n        if (err) reject(false);\n        if (reply === 1) {\n          resolve(true);\n        }\n        resolve(false);\n      });\n    });\n  }\n\n  /**\n   * Clear a group\n   * @param {string} key - key of the group to clean\n   */\n  clearGroup(key) {\n    return new Promise((resolve, reject) => {\n      this.client.lrange(key, 0, -1, (err, reply) => {\n        if (err) {\n          reject(err);\n        }\n        this.clearAll(reply).then(\n          this.client.del(key, (e, r) => {\n            resolve(r === 1);\n          })\n        );\n      });\n    });\n  }\n\n  /**\n   * Clear all keys of a redis list\n   * @param {Object[]} array\n   */\n  clearAll(array) {\n    return new Promise(resolve => {\n      if (!array.length) resolve(false);\n      let i = 0;\n\n      for (i; i < array.length; i++) {\n        this.clearSingle(array[i]).then(r => {\n          if (i === array.length - 1) {\n            resolve(r);\n          }\n        });\n      }\n    });\n  }\n};\n","import redis from 'redis';\nimport chalk from 'chalk';\n\nexport default function redisClient() { // eslint-disable-line no-unused-vars\n  const app = this;\n  const cacheOptions = app.get('redisCache') || {};\n  const retryInterval = cacheOptions.retryInterval || 10000;\n  const redisOptions = Object.assign({}, this.get('redis'), {\n    retry_strategy: function (options) { // eslint-disable-line camelcase\n      app.set('redisClient', undefined);\n      /* istanbul ignore next */\n      if (cacheOptions.env !== 'test') {\n        console.log(`${chalk.yellow('[redis]')} not connected`);\n      }\n      return retryInterval;\n    }\n  });\n  const client = redis.createClient(redisOptions);\n\n  app.set('redisClient', client);\n\n  client.on('ready', () => {\n    app.set('redisClient', client);\n    /* istanbul ignore next */\n    if (cacheOptions.env !== 'test') {\n      console.log(`${chalk.green('[redis]')} connected`);\n    }\n  });\n  return this;\n}\n","module.exports = require(\"redis\");","/**\n * After hook - generates a cache object that is needed\n * for the redis hook and the express middelware.\n */\nconst defaults = {\n  defaultDuration: 3600 * 24\n};\n\nexport function cache(options) { // eslint-disable-line no-unused-vars\n  return function (hook) {\n    const cacheOptions = hook.app.get('redisCache');\n\n    options = Object.assign({}, defaults, cacheOptions, options);\n\n    if (!hook.result.hasOwnProperty('cache')) {\n      let cache = {};\n\n      if (Array.isArray(hook.result)) {\n        const array = hook.result;\n\n        cache.wrapped = array;\n        hook.result = {};\n      }\n\n      cache = Object.assign({}, cache, {\n        cached: false,\n        duration: options.duration || options.defaultDuration\n      });\n\n      hook.result.cache = cache;\n    }\n    return Promise.resolve(hook);\n  };\n};\n\nexport function removeCacheInformation(options) { // eslint-disable-line no-unused-vars\n  return function (hook) {\n    if (hook.result.hasOwnProperty('cache')) {\n      delete hook.result.cache;\n    }\n    return Promise.resolve(hook);\n  };\n};\n","import moment from 'moment';\nimport chalk from 'chalk';\nimport { parsePath } from './helpers/path';\n\nconst defaults = {\n  env: 'production',\n  defaultDuration: 3600 * 24,\n  immediateCacheKey: false\n};\n\nexport function before(options) { // eslint-disable-line no-unused-vars\n  return function (hook) {\n    const cacheOptions = hook.app.get('redisCache');\n\n    options = Object.assign({}, defaults, cacheOptions, options);\n\n    return new Promise(resolve => {\n      const client = hook.app.get('redisClient');\n\n      if (!client) {\n        resolve(hook);\n      }\n\n      const path = parsePath(hook, options);\n\n      client.get(path, (err, reply) => {\n        if (err !== null) resolve(hook);\n        if (reply) {\n          let data = JSON.parse(reply);\n          const duration = moment(data.cache.expiresOn).format('DD MMMM YYYY - HH:mm:ss');\n\n          hook.result = data;\n          resolve(hook);\n\n          /* istanbul ignore next */\n          if (options.env !== 'test') {\n            console.log(`${chalk.cyan('[redis]')} returning cached value for ${chalk.green(path)}.`);\n            console.log(`> Expires on ${duration}.`);\n          }\n        } else {\n          if (options.immediateCacheKey === true) {\n            hook.params.cacheKey = path;\n          }\n          resolve(hook);\n        }\n      });\n    });\n  };\n};\n\nexport function after(options) { // eslint-disable-line no-unused-vars\n  return function (hook) {\n    const cacheOptions = hook.app.get('redisCache');\n\n    options = Object.assign({}, defaults, cacheOptions, options);\n\n    return new Promise(resolve => {\n      if (!hook.result.cache.cached) {\n        const duration = hook.result.cache.duration || options.defaultDuration;\n        const client = hook.app.get('redisClient');\n\n        if (!client) {\n          resolve(hook);\n        }\n\n        const path = hook.params.cacheKey || parsePath(hook, options);\n\n        // adding a cache object\n        Object.assign(hook.result.cache, {\n          cached: true,\n          duration: duration,\n          expiresOn: moment().add(moment.duration(duration, 'seconds')),\n          parent: hook.path,\n          group: hook.path ? `group-${hook.path}` : '',\n          key: path\n        });\n\n        client.set(path, JSON.stringify(hook.result));\n        client.expire(path, hook.result.cache.duration);\n\n        /* istanbul ignore next */\n        if (options.env !== 'test') {\n          console.log(`${chalk.cyan('[redis]')} added ${chalk.green(path)} to the cache.`);\n          console.log(`> Expires in ${moment.duration(duration, 'seconds').humanize()}.`);\n        }\n      }\n\n      if (hook.result.cache.hasOwnProperty('wrapped')) {\n        const { wrapped } = hook.result.cache;\n\n        hook.result = wrapped;\n      }\n\n      resolve(hook);\n    });\n  };\n};\n\n","module.exports = require(\"moment\");","import qs from 'qs';\n\nfunction parseNestedPath(path, params) {\n  const re = new RegExp(':([^\\\\/\\\\?]+)\\\\??', 'g');\n  let match = null;\n\n  while ((match = re.exec(path)) !== null) {\n    if (Object.keys(params.route).includes(match[1])) {\n      path = path.replace(match[0], params.route[match[1]]);\n    }\n  }\n\n  return path;\n}\n\nfunction parsePath(hook, config = {removePathFromCacheKey: false, parseNestedRoutes: false}) {\n  const q = hook.params.query || {};\n  const remove = config.removePathFromCacheKey;\n  const parseNestedRoutes = config.parseNestedRoutes;\n  let path = remove && hook.id ? '' : `${hook.path}`;\n\n  if (!remove && parseNestedRoutes) {\n    path = parseNestedPath(path, hook.params);\n  }\n\n  if (hook.id) {\n    if (path.length !== 0 && !remove) {\n      path += '/';\n    }\n    if (Object.keys(q).length > 0) {\n      path += `${hook.id}?${qs.stringify(q, { encode: false })}`;\n    } else {\n      path += `${hook.id}`;\n    }\n  } else {\n    if (Object.keys(q).length > 0) {\n      path += `?${qs.stringify(q, { encode: false })}`;\n    }\n  }\n\n  return path;\n}\n\nexport { parsePath };\n","module.exports = require(\"qs\");"],"sourceRoot":""}